要件定義書 
※現在、こちらはGoogle Docsをコピーしてペーストしたため、表示が崩れております。

1. プロジェクト概要

1.1 プロジェクト名

Smart Schedule (仮)

1.2 目的・背景

組織やグループ内での日程調整を、アカウント作成の壁を極限まで低くしつつ、柔軟かつ円滑に行うWebアプリケーションを開発する。既存のツールでは「ログインが手間で回答率が下がる」という課題に対し、ブラウザベースの簡易認証を用いつつ、「少し無理をすれば参加可能（△）」といった柔軟な意思表示と、それに基づく最適な日程のレコメンド機能を提供する。

1.3 ターゲットユーザー

アカウント登録を面倒に感じるグループメンバー（今回は固定の4名での合宿調整を想定）

スムーズに日程を決定したい幹事

2. システム構成

2.1 技術スタック

Frontend: React (TypeScript推奨)

ホスティング: Vercel

Backend: Python 3 (FastAPI)

ホスティング: Render

アーキテクチャ: クリーンアーキテクチャ指向

Database: PostgreSQL

ホスティング: Render

ORM / Migration: SQLAlchemy / Alembic

2.2 アーキテクチャ概要

フロントエンド(SPA)とバックエンド(RESTful API)を完全に分離したアーキテクチャを採用する。データの同一性保持はブラウザの localStorage を活用したUUIDベースで行い、将来的なJWTベースの本格的な認証認可システムへの移行を容易にする設計とする。

3. 機能要件 (Functional Requirements)

3.1 Phase 1: MVP (最小実行可能製品)

特定期間（例: 3/14~3/21）の合宿日程調整を完了させるための最小構成。

ID

機能区分

機能名

機能概要

F-01

ユーザー識別

簡易ID管理 (Fingerprinting)

初回アクセス時にUUID (v4) を発行し、localStorage に保存。APIリクエストのヘッダーに付与し、ログインレスで同一性を担保する。

F-02

イベント

イベント参照

システムに事前登録された調整対象イベント（期間・日程）の情報を取得し表示する。

F-03

回答登録

3段階ステータス登録

各候補日に対し、「参加可(◯)」「条件付き可(△)」「参加不可(✕)」の3段階で回答を登録・更新する。△の場合はコメント(条件)の入力を可能とする。

F-04

回答閲覧

マトリクス一覧表示

横軸に日程、縦軸にユーザーを配置した表形式で、全回答状況を一覧表示する。

F-05

回答編集

自己回答の修正・削除

localStorage 内のUUIDと照合し、自分自身の回答のみ修正および削除（白紙に戻す）を可能とする。

F-06

集計・推薦

ベスト日程レコメンド

全回答をバックエンドで集計し、参加可能スコア（例: ◯=2点, △=1点, ✕=0点）が高い順、かつ参加人数が多い順に日程をソートして提案する。

3.2 Phase 2: Future Scope (今後の機能拡張想定)

MVP達成後、汎用的なSaaS型日程調整ツールとして展開するための拡張要件。

ID

機能区分

機能名

機能概要

F-Ex1

イベント

イベント新規作成

ユーザーが任意の日程、タイトルを指定して新しいイベントを作成できる。

F-Ex2

イベント

共有URL発行

イベントごとの一意な共有URLを発行し、参加者を招待できる。

F-Ex3

認証認可

本格的アカウント管理

メールアドレス/パスワード、またはOAuth2による認証。JWTを用いたセキュアなセッション管理。

F-Ex4

セキュリティ

アクセス制御

イベントにパスワード保護や、特定の登録ユーザーのみがアクセスできる制限を設ける。

4. 非機能要件 (Non-Functional Requirements)

4.1 パフォーマンス・計算量

N+1問題の回避: データベースからの回答一覧取得時、ユーザーと回答データをO(1)のクエリで取得するようORM (Eager Loading) を最適化する。

レコメンド計算の最適化: 日程のスコア計算とソート処理はデータベース層（SQL集計）またはバックエンド層で$O(N \log N)$以下で効率的に処理し、フロントエンドの描画負荷を軽減する。

4.2 保守性・拡張性 (DevOps / Architecture)

DBマイグレーション: Alembicを導入し、テーブル定義の変更履歴をバージョン管理する。直接的なDB操作を禁止し、再現性を担保する。

クリーンアーキテクチャ: ルーティング(API)、ビジネスロジック(Service/UseCase)、データアクセス(CRUD/Repository)の責務を明確に分離したディレクトリ構成とする。

4.3 セキュリティ

SQLインジェクション対策: 全てのデータベース操作において、SQLAlchemy等のORMを利用し、プレースホルダーによるバインド変数を使用する。

CORS設定: フロントエンド(Vercel)からバックエンド(Render)へのAPIリクエストを許可するよう、厳密なCORSポリシーを設定する。
